import re
import argparse
from pathlib import Path
from datetime import datetime

# Regex to find a type list alias (e.g., using Pipeline = std::tuple<...>;)
PIPELINE_REGEX = re.compile(
    r"using\s+([a-zA-Z0-9_]+)\s*=\s*std::tuple<([^>]+)>;",
    re.MULTILINE | re.DOTALL
)

# Regex to find all #include statements.
INCLUDE_REGEX = re.compile(r'#include\s*["<]([^">]+)[">]')

# Template for the generated SystemManager header file
MANAGER_TEMPLATE = """//
// This file is auto-generated by SystemCodegen.py.
// Do not edit this file manually.
//
// Last Generated: {generation_date}
//

#pragma once

// Copied includes from the pipeline definition file
{system_includes}

namespace spite
{{
    class SystemManager
    {{
    EntityManager* m_entityManager;
    private:
{system_members}

    public:
		SystemManager(EntityManager* entityManager): m_entityManager(entityManager)
{system_initializers}
        {{
            // Call onInitialize for all systems
{system_on_initialize_calls}
        }}

        ~SystemManager()
        {{
            // Call onDestroy for all systems in reverse order
{system_on_destroy_calls}
        }}

        // --- System Execution Loops ---
{system_update_loops}
    }};
}}
"""

def parse_pipeline_file(pipeline_file: Path):
    """
    Parses the pipeline header file to find includes and pipeline definitions.
    Returns a tuple of (includes, pipelines, all_systems).
    """
    print(f"Parsing system pipeline definition from: {pipeline_file}...")
    if not pipeline_file.is_file():
        print(f"Error: Pipeline definition file not found at {pipeline_file}")
        return None, None, None

    try:
        with open(pipeline_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # Find all includes
        includes = INCLUDE_REGEX.findall(content)
        print(f"  Found {len(includes)} include directives.")

        # Find all pipelines
        pipelines = {}
        all_systems = set()
        matches = PIPELINE_REGEX.finditer(content)
        for match in matches:
            pipeline_name = match.group(1).strip()
            types_str = match.group(2).strip()
            types = [t.strip() for t in types_str.replace('\n', '').split(',') if t.strip()]
            pipelines[pipeline_name] = types
            all_systems.update(types)
            print(f"  Found pipeline '{pipeline_name}' with {len(types)} systems.")

        return includes, pipelines, sorted(list(all_systems))
    except Exception as e:
        print(f"Could not parse file {pipeline_file}: {e}")
        return None, None, None

def generate_manager_file(output_file: Path, includes: list, pipelines: dict, all_systems: list):
    """
    Generates the C++ header file for the SystemManager.
    """
    print(f"Generating SystemManager header at: {output_file}...")

    system_includes = [f'#include "{inc}"' for inc in includes]

    system_members = []
    system_initializers = []
    system_on_initialize_calls = []
    system_on_destroy_calls = []
    for system_name in all_systems:
        member_name = f"m_{system_name[0].lower()}{system_name[1:]}"
        system_members.append(f"        {system_name} {member_name};")
        system_initializers.append(f", {member_name}(entityManager)")
        system_on_initialize_calls.append(f"            {member_name}.onInitialize();")
        system_on_destroy_calls.append(f"            {member_name}.onDestroy();")

    system_update_loops = []
    for pipeline_name, systems in pipelines.items():
        loop_func_name = f"{pipeline_name[0].lower()}{pipeline_name[1:].replace('Pipeline', '')}"
        
        loop_body = []
        for system_name in systems:
            member_name = f"m_{system_name[0].lower()}{system_name[1:]}"
            loop_body.append(f"            if ({member_name}.isEnabled) {{ {member_name}.onUpdate(deltaTime); }}")
        
        system_update_loops.append(f"        void {loop_func_name}(float deltaTime)\n        {{\n// -- {pipeline_name} --\n{chr(10).join(loop_body)}\n        }}")

    content = MANAGER_TEMPLATE.format(
        generation_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        system_includes='\n'.join(system_includes),
        system_members='\n'.join(system_members),
        system_initializers='\n'.join(system_initializers),
        system_on_initialize_calls='\n'.join(system_on_initialize_calls),
        system_on_destroy_calls='\n'.join(reversed(system_on_destroy_calls)),
        system_update_loops='\n\n'.join(system_update_loops)
    )

    try:
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print("Successfully generated SystemManager header.")
    except Exception as e:
        print(f"Error writing to output file {output_file}: {e}")

def main():
    script_dir = Path(__file__).parent
    
    parser = argparse.ArgumentParser(
        description="Generates the SystemManager class from a pipeline definition header."
    )
    parser.add_argument(
        "--pipeline",
        type=Path,
        default=script_dir / "../source/ecs/SystemPipeline.hpp",
        help="The path to the C++ header file defining the system pipelines."
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=script_dir / "../source/ecs/GeneratedSystemManager.hpp",
        help="The path to the output C++ header file to be generated."
    )
    args = parser.parse_args()

    pipeline_file = args.pipeline.resolve()
    output_file = args.output.resolve()

    includes, pipelines, all_systems_in_pipelines = parse_pipeline_file(pipeline_file)
    if not pipelines:
        print("No pipelines found. Aborting.")
        return

    generate_manager_file(output_file, includes, pipelines, all_systems_in_pipelines)

if __name__ == "__main__":
    main()