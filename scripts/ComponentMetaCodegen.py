import os
import re
import argparse
from pathlib import Path

# Regex to find structs/classes inheriting from IComponent.
# It captures the component name in group 1.
# Handles 'struct' or 'class', optional access specifiers, and optional 'spite::' namespace.
# It is designed to match the start of a line to avoid matching comments or other usages.
COMPONENT_REGEX = re.compile(
    r"^\s*(?:struct|class)\s+([a-zA-Z0-9_]+)\s*:\s*(?:public|protected|private)?\s*(?:spite::)?IComponent\b"
)

# Template for the generated C++ file
CPP_TEMPLATE = """//
// This file is auto-generated by generate_component_registry.py.
// Do not edit this file manually.
//
// Last Generated: {generation_date}
//

#include "ecs/ComponentMetadata.hpp"

// Discovered component headers:
{includes}

namespace spite 
{{
    // Function to register all discovered components.
    // Call this once at application startup.
    void registerAllComponents(ComponentMetadataRegistry& registry)
    {{
{registrations}
    }}
}}
"""

def find_components_in_directory(source_dir: Path):
    """
    Scans a directory recursively for .h and .hpp files, finding all
    structs/classes that inherit from spite::IComponent.

    Returns:
        A tuple containing:
        - A set of relative paths to headers containing components.
        - A set of component names found.
    """
    print(f"Scanning for components in: {source_dir}...")
    
    header_paths = set()
    component_names = set()

    for root, _, files in os.walk(source_dir):
        for file in files:
            if file.endswith((".hpp", ".h")):
                file_path = Path(root) / file
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content_lines = f.readlines()
                    
                    file_had_component = False
                    for line in content_lines:
                        match = COMPONENT_REGEX.match(line)
                        if match:
                            component_name = match.group(1)
                            component_names.add(component_name)
                            file_had_component = True
                
                    if file_had_component:
                        # Get path relative to the source directory for includes
                        relative_path = file_path.relative_to(source_dir)
                        # Use forward slashes for include paths
                        header_paths.add(relative_path.as_posix())

                except Exception as e:
                    print(f"Could not process file {file_path}: {e}")

    print(f"Scan complete. Found {len(component_names)} components in {len(header_paths)} files.")
    return sorted(list(header_paths)), sorted(list(component_names))


def generate_registration_file(output_file: Path, header_paths: list, component_names: list):
    """
    Generates the C++ source file with the registration function.
    """
    print(f"Generating registration file at: {output_file}...")

    # Format the #include statements
    includes_str = "\n".join([f'#include "{path}"' for path in header_paths])

    # Format the registry.registerComponent<T>() calls
    registrations_str = "\n".join([f'        registry.registerComponent<{name}>();' for name in component_names])

    from datetime import datetime
    generation_date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Populate the main template
    content = CPP_TEMPLATE.format(
        generation_date=generation_date_str,
        includes=includes_str,
        registrations=registrations_str
    )

    try:
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print("Successfully generated registration file.")
    except Exception as e:
        print(f"Error writing to output file {output_file}: {e}")


def main():
    # Get the directory where this script is located
    script_dir = Path(__file__).parent
    
    parser = argparse.ArgumentParser(
        description="Scans for spite::IComponent derivatives and generates a C++ registration file."
    )
    parser.add_argument(
        "--source",
        type=Path,
        default=script_dir / "../source",  # Relative to script location
        help="The root source directory to scan for components."
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=script_dir / "../source/ecs/GeneratedComponentRegistration.cpp",  # Relative to script location
        help="The path to the output C++ file to be generated."
    )
    args = parser.parse_args()

    # Resolve the paths to absolute paths
    source_path = args.source.resolve()
    output_path = args.output.resolve()

    if not source_path.is_dir():
        print(f"Error: ComponentMetaCodegen: Source directory not found at '{source_path}'")
        return

    header_paths, component_names = find_components_in_directory(source_path)
    
    if not component_names:
        print("Warning: No components found. Generated file will be empty.")

    generate_registration_file(output_path, header_paths, component_names)


if __name__ == "__main__":
    main()