import os
import re
import argparse
from pathlib import Path

# Regex to find structs/classes inheriting from IComponent (but not ISharedComponent)
COMPONENT_REGEX = re.compile(
    r"^\s*(?:struct|class)\s+([a-zA-Z0-9_]+)\s*:\s*(?:public|protected|private)?\s*(?:spite::)?IComponent\b"
)

# Regex to find structs/classes inheriting from the ISharedComponent marker interface
SHARED_COMPONENT_REGEX = re.compile(
    r"^\s*(?:struct|class)\s+([a-zA-Z0-9_]+)\s*:\s*(?:public|protected|private)?\s*(?:spite::)?ISharedComponent\b"
)

# Template for the generated C++ file
CPP_TEMPLATE = """//
// This file is auto-generated by ComponentMetaCodegen.py.
// Do not edit this file manually.
//
// Last Generated: {generation_date}
//

#pragma once
#include "ecs/core/ComponentMetadataRegistry.hpp"

// Discovered component headers:
{includes}

namespace spite 
{{
    // Function to register all discovered components.
    // Registry calls it itself on construction.
    inline void registerAllComponents(ComponentMetadataInitializer& registry)
    {{
{registrations}
    }}
}}
"""

# Template for the generated C++ header file
HPP_TEMPLATE = """//
// This file is auto-generated by ComponentMetaCodegen.py.
// Do not edit this file manually.
//
// Last Generated: {generation_date}
//

#pragma once
#include "ecs/core/ComponentMetadata.hpp"

namespace spite
{{
    constexpr ComponentID MAX_COMPONENTS = {component_count};
}}
"""

def find_components_in_directory(source_dir: Path):
    """
    Scans a directory recursively for .h and .hpp files, finding all
    structs/classes that inherit from IComponent or ISharedComponent.

    Returns:
        A tuple containing:
        - A set of relative paths to headers containing components.
        - A list of registration calls (as strings).
    """
    print(f"Scanning for components in: {source_dir}...")
    
    header_paths = set()
    registration_calls = []

    for root, _, files in os.walk(source_dir):
        for file in files:
            if file.endswith((".hpp", ".h")):
                file_path = Path(root) / file
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content_lines = f.readlines()
                    
                    file_had_component = False
                    for line in content_lines:
                        # Check for regular components
                        match = COMPONENT_REGEX.match(line)
                        if match:
                            component_name = match.group(1)
                            # Avoid matching the SharedComponent<T> template itself
                            if not component_name.startswith('SharedComponent'):
                                registration_calls.append(f'registry.registerComponent<{component_name}>();')
                                file_had_component = True

                        # Check for shared component data
                        shared_match = SHARED_COMPONENT_REGEX.match(line)
                        if shared_match:
                            shared_component_name = shared_match.group(1)
                            # Generate registration for the handle, not the data itself
                            registration_calls.append(f'registry.registerComponent<SharedComponent<{shared_component_name}>>();')
                            file_had_component = True
                
                    if file_had_component:
                        relative_path = file_path.relative_to(source_dir)
                        header_paths.add(relative_path.as_posix())

                except Exception as e:
                    print(f"Could not process file {file_path}: {e}")

    print(f"Scan complete. Found {len(registration_calls)} components to register in {len(header_paths)} files.")
    return sorted(list(header_paths)), sorted(registration_calls)


def generate_registration_file(output_file: Path, header_paths: list, registration_calls: list):
    """
    Generates the C++ source file with the registration function.
    """
    print(f"Generating registration file at: {output_file}...")

    includes_str = "\n".join([f'#include "{path}"' for path in header_paths])
    registrations_str = "\n".join([f'        {call}' for call in registration_calls])

    from datetime import datetime
    generation_date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    content = CPP_TEMPLATE.format(
        generation_date=generation_date_str,
        includes=includes_str,
        registrations=registrations_str
    )

    try:
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print("Successfully generated registration file.")
    except Exception as e:
        print(f"Error writing to output file {output_file}: {e}")

def generate_count_header(output_header: Path, component_count: int):
    """
    Generates the C++ header file with the component count.
    """
    print(f"Generating component count header at: {output_header}...")

    from datetime import datetime
    generation_date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    content = HPP_TEMPLATE.format(
        generation_date=generation_date_str,
        component_count=component_count
    )

    try:
        output_header.parent.mkdir(parents=True, exist_ok=True)
        with open(output_header, 'w', encoding='utf-8') as f:
            f.write(content)
        print("Successfully generated component count header.")
    except Exception as e:
        print(f"Error writing to output file {output_header}: {e}")

def main():
    script_dir = Path(__file__).parent
    
    parser = argparse.ArgumentParser(
        description="Scans for spite::IComponent and spite::ISharedComponent derivatives and generates a C++ registration file."
    )
    parser.add_argument(
        "--source",
        type=Path,
        default=script_dir / "../source",
        help="The root source directory to scan for components."
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=script_dir / "../source/ecs/generated/GeneratedComponentRegistration.hpp",
        help="The path to the output C++ header file to be generated."
    )
    parser.add_argument(
        "--output-header",
        type=Path,
        default=script_dir / "../source/ecs/generated/GeneratedComponentCount.hpp",
        help="The path to the output C++ header file to be generated."
    )
    args = parser.parse_args()

    source_path = args.source.resolve()
    output_path = args.output.resolve()
    output_header_path = args.output_header.resolve()

    if not source_path.is_dir():
        print(f"Error: ComponentMetaCodegen: Source directory not found at '{source_path}'")
        return

    header_paths, registration_calls = find_components_in_directory(source_path)
    
    if not registration_calls:
        print("Warning: No components found. Generated file will be empty.")

    generate_registration_file(output_path, header_paths, registration_calls)
    # The number of components is the number of registration calls.
    generate_count_header(output_header_path, len(registration_calls))


if __name__ == "__main__":
    main()